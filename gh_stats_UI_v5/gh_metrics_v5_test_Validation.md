# GitHub Metrics Validation Guide

## Overview

This guide provides tools and commands to validate the metrics generated by the GitHub Metrics Reporter. Use these methods to verify the accuracy of metrics in your reports, identify discrepancies, and understand how the numbers are calculated.

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Validation Tools](#validation-tools)
3. [Core Metrics Validation](#core-metrics-validation)
4. [Python Validation Script](#python-validation-script)
5. [Bash Validation Scripts](#bash-validation-scripts)
6. [Common Discrepancies](#common-discrepancies)
7. [Metric-Specific Validation](#metric-specific-validation)

## Prerequisites

Before you begin validation, ensure you have the following:

1. **GitHub Personal Access Token**
   - Must have `repo` scope for private repositories
   - For public repositories, `public_repo` scope is sufficient
   - Set as an environment variable: `export GITHUB_TOKEN=your_token_here`

2. **Required Tools**
   - curl (for API requests)
   - jq (for JSON processing): Install from https://stedolan.github.io/jq/download/
   - GitHub CLI (optional): Install from https://cli.github.com/
   - Python 3.6+ (for the Python validation script)

3. **Python Dependencies**
   ```
   pip install requests python-dateutil
   ```

4. **Validation Target Information**
   - Organization/repo name
   - Date range used in the original report
   - PR threshold days (default: 7)
   - Label threshold (default: 2)

## Validation Tools

This guide provides three types of validation tools:

1. **Individual curl/GitHub CLI commands** - For quick validation of specific metrics
2. **Python validation script** - For comprehensive validation of all metrics
3. **Bash validation scripts** - For focused validation of specific metric areas

Choose the approach that best fits your needs based on the scope of validation required.

## Core Metrics Validation

### Step 1: Verify Repository Access

First, ensure your token has the required access:

```bash
# Using curl
curl -s -H "Authorization: token $GITHUB_TOKEN" \
  "https://api.github.com/repos/{org}/{repo}"

# Using GitHub CLI
gh api repos/{org}/{repo}
```

Replace `{org}` and `{repo}` with your organization and repository names.

### Step 2: Validate PR Count

Verify the total number of PRs in the time period:

```bash
# Using curl
curl -s -H "Authorization: token $GITHUB_TOKEN" \
  "https://api.github.com/repos/{org}/{repo}/pulls?state=all&per_page=100" | \
  jq '[.[] | select(.created_at >= "2023-01-01T00:00:00Z" and .created_at <= "2023-12-31T23:59:59Z")] | length'

# Using GitHub CLI
gh api repos/{org}/{repo}/pulls \
  --method GET \
  --field state=all \
  --field per_page=100 \
  --jq '[.[] | select(.created_at >= "2023-01-01T00:00:00Z" and .created_at <= "2023-12-31T23:59:59Z")] | length'
```

Replace the date strings with your report's start and end dates.

### Step 3: Validate Commit Counts

Check commits for a specific PR:

```bash
# Using curl
curl -s -H "Authorization: token $GITHUB_TOKEN" \
  "https://api.github.com/repos/{org}/{repo}/pulls/{pr_number}/commits?per_page=100" | \
  jq 'length'

# Using GitHub CLI
gh api repos/{org}/{repo}/pulls/{pr_number}/commits \
  --method GET \
  --field per_page=100 \
  --jq 'length'
```

Replace `{pr_number}` with the PR number you want to validate.

### Step 4: Validate PR Health Status

Check if a PR is healthy based on duration and label count:

```bash
# Using curl to get PR details
curl -s -H "Authorization: token $GITHUB_TOKEN" \
  "https://api.github.com/repos/{org}/{repo}/pulls/{pr_number}" | \
  jq '{created_at, closed_at, state, label_count: (.labels | length)}'
```

Manually calculate if the PR is healthy:
- Healthy: Created < 7 days ago (or closed within 7 days) AND has â‰¤ 2 labels
- Needs Attention: Created > 7 days ago OR has > 2 labels

## Python Validation Script

For comprehensive validation, use the Python script below. Save it as `validate_github_metrics.py`:

```python
#!/usr/bin/env python3
import requests
import datetime
import argparse
import os
import time
import sys
from dateutil.parser import parse

class GitHubMetricsValidator:
    """
    A tool to validate GitHub metrics reported by the GitHub Metrics Reporter.
    This closely mimics the logic in the reporter to verify the accuracy of metrics.
    """
    
    def __init__(self, token, pr_threshold_days=7, max_labels_threshold=2):
        """Initialize with GitHub token and configurable thresholds."""
        self.token = token
        self.headers = {
            "Authorization": f"token {token}",
            "Accept": "application/vnd.github.v3+json"
        }
        self.pr_threshold_days = pr_threshold_days
        self.max_labels_threshold = max_labels_threshold
        self.api_calls = 0
    
    def get_with_pagination(self, url, params=None):
        """
        Get all pages of results from GitHub API with pagination handling.
        This ensures we get ALL results, not just the first 100.
        """
        all_results = []
        page = 1
        while True:
            page_params = {**(params or {}), "page": page, "per_page": 100}
            
            # Track API calls to avoid rate limits
            self.api_calls += 1
            if self.api_calls % 50 == 0:
                print(f"Made {self.api_calls} API calls, sleeping to avoid rate limits...")
                time.sleep(3)
            
            response = requests.get(url, headers=self.headers, params=page_params)
            
            if response.status_code == 403 and 'rate limit exceeded' in response.text:
                reset_time = int(response.headers.get('X-RateLimit-Reset', 0))
                wait_time = max(reset_time - time.time(), 0) + 5
                print(f"Rate limit exceeded. Waiting {wait_time:.1f} seconds...")
                time.sleep(wait_time)
                continue
            
            response.raise_for_status()
            page_results = response.json()
            
            if not page_results:
                break
                
            all_results.extend(page_results)
            
            # Break if we get less than a full page
            if len(page_results) < 100:
                break
                
            page += 1
        
        return all_results
    
    def get_prs_in_date_range(self, org, repo, start_date, end_date):
        """Get all PRs created within the specified date range."""
        url = f"https://api.github.com/repos/{org}/{repo}/pulls"
        params = {
            "state": "all",        # Get all PRs (open, closed, merged)
            "sort": "created",     # Sort by creation date
            "direction": "desc"    # Most recent first
        }
        
        print(f"Fetching PRs for {org}/{repo}...")
        all_prs = self.get_with_pagination(url, params)
        
        # Filter PRs by creation date
        filtered_prs = []
        for pr in all_prs:
            created_at = parse(pr["created_at"])
            if start_date <= created_at <= end_date:
                filtered_prs.append(pr)
            elif created_at < start_date:
                # Since we're sorting by date desc, we can stop once we hit PRs before our start date
                break
        
        print(f"Found {len(filtered_prs)} PRs in date range.")
        return filtered_prs
    
    def get_pr_commits(self, org, repo, pr_number):
        """Get all commits for a specific PR."""
        url = f"https://api.github.com/repos/{org}/{repo}/pulls/{pr_number}/commits"
        return self.get_with_pagination(url)
    
    def get_pr_files(self, org, repo, pr_number):
        """Get files changed in a PR."""
        url = f"https://api.github.com/repos/{org}/{repo}/pulls/{pr_number}/files"
        return self.get_with_pagination(url)
    
    def get_check_runs(self, org, repo, commit_sha):
        """Get check runs for a specific commit."""
        url = f"https://api.github.com/repos/{org}/{repo}/commits/{commit_sha}/check-runs"
        response = requests.get(url, headers=self.headers)
        self.api_calls += 1
        
        if response.status_code != 200:
            return {'total': 0, 'passed': 0, 'failed': 0}
        
        checks = response.json().get('check_runs', [])
        
        total_checks = len(checks)
        passed_checks = sum(1 for check in checks if check.get('conclusion') == 'success')
        failed_checks = sum(1 for check in checks if check.get('conclusion') in ['failure', 'cancelled', 'timed_out'])
        
        return {
            'total': total_checks,
            'passed': passed_checks,
            'failed': failed_checks
        }
    
    def get_pr_reviews(self, org, repo, pr_number):
        """Get all reviews for a PR."""
        url = f"https://api.github.com/repos/{org}/{repo}/pulls/{pr_number}/reviews"
        return self.get_with_pagination(url)
    
    def determine_pr_health(self, pr, pr_duration_days, label_count):
        """
        Determine if a PR is healthy based on duration and label count.
        This uses the same logic as the GitHub Metrics Reporter.
        """
        health_status = "Healthy"
        health_reasons = []
        
        # Check duration threshold
        if pr_duration_days > self.pr_threshold_days:
            health_status = "Needs Attention"
            health_reasons.append(f"PR open > {self.pr_threshold_days} days")
        
        # Check label threshold
        if label_count > self.max_labels_threshold:
            health_status = "Needs Attention"
            health_reasons.append(f"PR has > {self.max_labels_threshold} labels")
        
        return health_status, health_reasons
    
    def validate_repo_metrics(self, org, repo, start_date, end_date):
        """
        Validate metrics for a repository.
        This replicates the core logic of the GitHub Metrics Reporter.
        """
        # Initialize metrics counters
        metrics = {
            'total_prs': 0,
            'merged_prs': 0,
            'open_prs': 0,
            'healthy_prs': 0,
            'needs_attention_prs': 0,
            'needs_attention_due_to_duration': 0,
            'needs_attention_due_to_labels': 0,
            'total_commits': 0,
            'total_additions': 0,
            'total_deletions': 0,
            'total_passed_checks': 0,
            'total_failed_checks': 0,
            'total_files_changed': 0
        }
        
        # Track contributors and their metrics
        contributors = {}
        
        # Get PRs in date range
        prs = self.get_prs_in_date_range(org, repo, start_date, end_date)
        metrics['total_prs'] = len(prs)
        
        # Process each PR
        for i, pr in enumerate(prs):
            print(f"Processing PR #{pr['number']} ({i+1}/{len(prs)})...")
            
            # Get basic PR data
            pr_number = pr['number']
            author = pr['user']['login']
            state = pr['state']
            label_count = len(pr.get('labels', []))
            
            # Initialize contributor if not seen before
            if author not in contributors:
                contributors[author] = {
                    'total_prs': 0,
                    'healthy_prs': 0,
                    'needs_attention_prs': 0,
                    'total_commits': 0,
                    'total_additions': 0,
                    'total_deletions': 0,
                    'passed_checks': 0,
                    'failed_checks': 0
                }
            
            # Track PR by author
            contributors[author]['total_prs'] += 1
            
            # Calculate PR duration
            created_at = parse(pr['created_at'])
            if pr['state'] == 'closed' and pr['closed_at']:
                closed_at = parse(pr['closed_at'])
                pr_duration_days = (closed_at - created_at).days
            else:
                # For open PRs, calculate days open so far
                pr_duration_days = (datetime.datetime.now(datetime.timezone.utc) - created_at).days
            
            # Track PR status
            if state == 'closed' and pr.get('merged_at'):
                metrics['merged_prs'] += 1
            elif state == 'open':
                metrics['open_prs'] += 1
            
            # Determine PR health
            health_status, health_reasons = self.determine_pr_health(pr, pr_duration_days, label_count)
            
            if health_status == "Healthy":
                metrics['healthy_prs'] += 1
                contributors[author]['healthy_prs'] += 1
            else:
                metrics['needs_attention_prs'] += 1
                contributors[author]['needs_attention_prs'] += 1
                
                # Track reasons for needs attention status
                if any("PR open >" in reason for reason in health_reasons):
                    metrics['needs_attention_due_to_duration'] += 1
                if any("PR has >" in reason for reason in health_reasons):
                    metrics['needs_attention_due_to_labels'] += 1
            
            # Get commits for this PR
            pr_commits = self.get_pr_commits(org, repo, pr_number)
            metrics['total_commits'] += len(pr_commits)
            contributors[author]['total_commits'] += len(pr_commits)
            
            # Get check runs for each commit
            total_passed_checks = 0
            total_failed_checks = 0
            
            for commit in pr_commits:
                commit_sha = commit.get('sha', '')
                check_runs = self.get_check_runs(org, repo, commit_sha)
                total_passed_checks += check_runs['passed']
                total_failed_checks += check_runs['failed']
            
            metrics['total_passed_checks'] += total_passed_checks
            metrics['total_failed_checks'] += total_failed_checks
            contributors[author]['passed_checks'] += total_passed_checks
            contributors[author]['failed_checks'] += total_failed_checks
            
            # Get file changes
            pr_files = self.get_pr_files(org, repo, pr_number)
            total_additions = sum(file.get('additions', 0) for file in pr_files)
            total_deletions = sum(file.get('deletions', 0) for file in pr_files)
            
            metrics['total_additions'] += total_additions
            metrics['total_deletions'] += total_deletions
            metrics['total_files_changed'] += len(pr_files)
            
            contributors[author]['total_additions'] += total_additions
            contributors[author]['total_deletions'] += total_deletions
            
            # Get reviews for tracking review activity
            reviews = self.get_pr_reviews(org, repo, pr_number)
            
            # Process reviewers
            approvers = set()
            approvals_with_comments = 0
            approvals_without_comments = 0
            change_requests = 0
            
            for review in reviews:
                reviewer = review.get('user', {}).get('login', '')
                if reviewer == author:
                    continue  # Skip self-reviews
                
                review_state = review.get('state', '').upper()
                
                # Initialize reviewer in contributors if needed
                if reviewer and reviewer not in contributors:
                    contributors[reviewer] = {
                        'total_prs': 0,
                        'healthy_prs': 0,
                        'needs_attention_prs': 0,
                        'total_commits': 0,
                        'total_additions': 0,
                        'total_deletions': 0,
                        'passed_checks': 0,
                        'failed_checks': 0,
                        'prs_approved': 0,
                        'change_requests': 0
                    }
                
                # Process APPROVED reviews
                if review_state == 'APPROVED':
                    approvers.add(reviewer)
                    if reviewer in contributors:
                        contributors[reviewer]['prs_approved'] = contributors[reviewer].get('prs_approved', 0) + 1
                    
                    # Check if approver provided comments
                    if review.get('body') and review.get('body').strip():
                        approvals_with_comments += 1
                    else:
                        approvals_without_comments += 1
                
                # Process CHANGES_REQUESTED reviews
                elif review_state == 'CHANGES_REQUESTED':
                    change_requests += 1
                    if reviewer in contributors:
                        contributors[reviewer]['change_requests'] = contributors[reviewer].get('change_requests', 0) + 1
        
        # Calculate health percentage
        if metrics['total_prs'] > 0:
            metrics['health_percentage'] = round((metrics['healthy_prs'] / metrics['total_prs']) * 100, 1)
        else:
            metrics['health_percentage'] = 100  # 100% healthy by default if no PRs
        
        # Print summary
        print("\n" + "="*50)
        print(f"VALIDATION RESULTS FOR {org}/{repo}")
        print("="*50)
        print(f"Time Period: {start_date.isoformat()} to {end_date.isoformat()}")
        print(f"Total PRs: {metrics['total_prs']}")
        print(f"Merged PRs: {metrics['merged_prs']}")
        print(f"Open PRs: {metrics['open_prs']}")
        print(f"Healthy PRs: {metrics['healthy_prs']}")
        print(f"Needs Attention PRs: {metrics['needs_attention_prs']}")
        print(f"Needs Attention Due to Duration: {metrics['needs_attention_due_to_duration']}")
        print(f"Needs Attention Due to Labels: {metrics['needs_attention_due_to_labels']}")
        print(f"Health Percentage: {metrics['health_percentage']}%")
        print(f"Total Commits: {metrics['total_commits']}")
        print(f"Total Additions: {metrics['total_additions']}")
        print(f"Total Deletions: {metrics['total_deletions']}")
        print(f"Total Files Changed: {metrics['total_files_changed']}")
        print(f"Passed Checks: {metrics['total_passed_checks']}")
        print(f"Failed Checks: {metrics['total_failed_checks']}")
        print(f"Total Contributors: {len(contributors)}")
        
        # Print top contributors
        print("\nTop Contributors by Commit Count:")
        for author, stats in sorted(contributors.items(), key=lambda x: x[1]['total_commits'], reverse=True)[:10]:
            health_pct = 0
            if stats['total_prs'] > 0:
                health_pct = round((stats['healthy_prs'] / stats['total_prs']) * 100, 1)
            
            print(f"  {author}:")
            print(f"    PRs: {stats['total_prs']} ({stats['healthy_prs']} healthy, {stats['needs_attention_prs']} needs attention)")
            print(f"    Commits: {stats['total_commits']}")
            print(f"    Health %: {health_pct}%")
            if 'prs_approved' in stats:
                print(f"    PRs Approved: {stats.get('prs_approved', 0)}")
            if 'change_requests' in stats:
                print(f"    Change Requests: {stats.get('change_requests', 0)}")
        
        return metrics, contributors

def main():
    parser = argparse.ArgumentParser(description="Validate GitHub repository metrics")
    parser.add_argument("--org", required=True, help="GitHub organization/owner name")
    parser.add_argument("--repo", required=True, help="GitHub repository name")
    parser.add_argument("--start-date", required=True, help="Start date in YYYY-MM-DD format")
    parser.add_argument("--end-date", required=True, help="End date in YYYY-MM-DD format")
    parser.add_argument("--pr-threshold", type=int, default=7, help="PR health threshold in days (default: 7)")
    parser.add_argument("--label-threshold", type=int, default=2, help="Maximum labels threshold (default: 2)")
    parser.add_argument("--token", help="GitHub token (if not provided, will use GITHUB_TOKEN env var)")
    
    args = parser.parse_args()
    
    # Get GitHub token
    token = args.token or os.environ.get("GITHUB_TOKEN")
    if not token:
        print("Error: GitHub token not provided. Please set GITHUB_TOKEN environment variable or use --token")
        sys.exit(1)
    
    # Parse dates
    try:
        start_date = datetime.datetime.strptime(args.start_date, "%Y-%m-%d")
        start_date = start_date.replace(tzinfo=datetime.timezone.utc)
        
        end_date = datetime.datetime.strptime(args.end_date, "%Y-%m-%d")
        end_date = end_date.replace(hour=23, minute=59, second=59, tzinfo=datetime.timezone.utc)
        
        if start_date >= end_date:
            print("Error: Start date must be before end date")
            sys.exit(1)
            
    except ValueError as e:
        print(f"Error parsing dates: {str(e)}")
        sys.exit(1)
    
    # Create validator and run validation
    validator = GitHubMetricsValidator(
        token=token,
        pr_threshold_days=args.pr_threshold,
        max_labels_threshold=args.label_threshold
    )
    
    print(f"Validating metrics for {args.org}/{args.repo}")
    print(f"Using thresholds: PR duration â‰¤ {args.pr_threshold} days, Labels â‰¤ {args.label_threshold}")
    print(f"Date range: {args.start_date} to {args.end_date}")
    
    validator.validate_repo_metrics(args.org, args.repo, start_date, end_date)

if __name__ == "__main__":
    main()
```

### Using the Python Validation Script

1. **Install dependencies**
   ```bash
   pip install requests python-dateutil
   ```

2. **Run the validation**
   ```bash
   python validate_github_metrics.py \
     --org your-org \
     --repo your-repo \
     --start-date 2023-01-01 \
     --end-date 2023-12-31 \
     --pr-threshold 7 \
     --label-threshold 2
   ```

3. **Compare results**
   - The script will output metrics that should match your GitHub Metrics Report
   - Focus on the summary values for discrepancy investigation

## Bash Validation Scripts

For targeted validation of specific metric areas, use these bash scripts.

### 1. PR Count and Commit Validation Script

Save this as `validate_pr_commits.sh`:

```bash
#!/bin/bash
# This script calculates total commits across all PRs created within a date range

ORG="your-org"                  # Your GitHub organization name
REPO="your-repo"                # Your repository name
START_DATE="2023-01-01T00:00:00Z"  # Analysis start date in ISO 8601 format
END_DATE="2023-12-31T23:59:59Z"    # Analysis end date in ISO 8601 format
TOKEN="$GITHUB_TOKEN"           # Your GitHub token from environment variable

# Step 1: Get all PRs created within the date range (handling pagination)
page=1
all_prs=()
while true; do
  # Fetch a page of PRs
  echo "Fetching page $page of PRs..."
  page_result=$(curl -s -H "Authorization: token $TOKEN" \
    -H "Accept: application/vnd.github.v3+json" \
    "https://api.github.com/repos/$ORG/$REPO/pulls?state=all&sort=created&direction=desc&per_page=100&page=$page")
  
  # Extract PRs within the date range
  filtered_prs=$(echo "$page_result" | jq -c "[.[] | select(.created_at >= \"$START_DATE\" and .created_at <= \"$END_DATE\")]")
  
  # Check if we got any results
  count=$(echo "$filtered_prs" | jq 'length')
  if [[ $count -eq 0 ]]; then
    # No more PRs in this page or no more pages
    # Break if the array is empty (end of pages) or no filtered results
    if [[ $(echo "$page_result" | jq 'length') -eq 0 ]]; then
      break
    fi
  fi
  
  # Add these PRs to our collection
  all_prs+=($(echo "$filtered_prs" | jq -r '.[].number'))
  page=$((page + 1))
  
  # Avoid hitting rate limits - pause between requests
  sleep 0.5
done

echo "Found ${#all_prs[@]} PRs within the date range"

# Step 2: Get commit count for each PR
total_commits=0
total_prs=0
for pr in "${all_prs[@]}"; do
  # Get commits for this PR (also with pagination handling)
  pr_commit_count=0
  commit_page=1
  
  while true; do
    commit_result=$(curl -s -H "Authorization: token $TOKEN" \
      -H "Accept: application/vnd.github.v3+json" \
      "https://api.github.com/repos/$ORG/$REPO/pulls/$pr/commits?per_page=100&page=$commit_page")
    
    # Count commits in this page
    page_count=$(echo "$commit_result" | jq 'length')
    pr_commit_count=$((pr_commit_count + page_count))
    
    # Break if no more commits
    if [[ $page_count -lt 100 ]]; then
      break
    fi
    
    commit_page=$((commit_page + 1))
    sleep 0.5  # Avoid rate limits
  done
  
  echo "PR #$pr: $pr_commit_count commits"
  total_commits=$((total_commits + pr_commit_count))
  total_prs=$((total_prs + 1))
done

echo "----------------------------"
echo "Total PRs analyzed: $total_prs"
echo "Total commits across all PRs: $total_commits"
echo "----------------------------"
```

### 2. PR Health Validation Script

Save this as `validate_pr_health.sh`:

```bash
#!/bin/bash
# This script validates the PR health status calculation

ORG="your-org"                  # Organization name
REPO="your-repo"                # Repository name
TOKEN="$GITHUB_TOKEN"           # GitHub token
PR_THRESHOLD_DAYS=7             # PR health threshold in days (configurable)
MAX_LABELS_THRESHOLD=2          # Maximum labels threshold (configurable)
START_DATE="2023-01-01T00:00:00Z"  # Analysis start date
END_DATE="2023-12-31T23:59:59Z"    # Analysis end date

echo "Validating PR health calculations for $ORG/$REPO"
echo "Health thresholds: PR duration â‰¤ $PR_THRESHOLD_DAYS days AND labels â‰¤ $MAX_LABELS_THRESHOLD"
echo "Period: $START_DATE to $END_DATE"
echo "----------------------------"

# Get PRs in date range (with pagination)
page=1
healthy_prs=0
needs_attention_prs=0
unhealthy_due_to_duration=0
unhealthy_due_to_labels=0

while true; do
  echo "Fetching page $page of PRs..."
  result=$(curl -s -H "Authorization: token $TOKEN" \
    -H "Accept: application/vnd.github.v3+json" \
    "https://api.github.com/repos/$ORG/$REPO/pulls?state=all&sort=created&direction=desc&per_page=100&page=$page")
  
  # Extract PRs within date range
  filtered_prs=$(echo "$result" | jq -c "[.[] | select(.created_at >= \"$START_DATE\" and .created_at <= \"$END_DATE\")]")
  count=$(echo "$filtered_prs" | jq 'length')
  
  if [[ $count -eq 0 ]]; then
    if [[ $(echo "$result" | jq 'length') -eq 0 ]]; then
      break
    fi
  fi
  
  # Process each PR
  for pr_data in $(echo "$filtered_prs" | jq -c '.[]'); do
    pr_number=$(echo "$pr_data" | jq '.number')
    created_at=$(echo "$pr_data" | jq -r '.created_at')
    closed_at=$(echo "$pr_data" | jq -r '.closed_at')
    state=$(echo "$pr_data" | jq -r '.state')
    label_count=$(echo "$pr_data" | jq '.labels | length')
    
    # Calculate PR duration
    created_date=$(date -d "$created_at" +%s)
    
    if [[ "$state" == "closed" && "$closed_at" != "null" ]]; then
      closed_date=$(date -d "$closed_at" +%s)
      pr_duration_days=$(( (closed_date - created_date) / 86400 ))
    else
      # For open PRs, calculate days open so far
      current_date=$(date +%s)
      pr_duration_days=$(( (current_date - created_date) / 86400 ))
    fi
    
    # Determine PR health
    is_healthy=true
    health_reasons=""
    
    if [[ $pr_duration_days -gt $PR_THRESHOLD_DAYS ]]; then
      is_healthy=false
      unhealthy_due_to_duration=$((unhealthy_due_to_duration + 1))
      health_reasons="PR open > $PR_THRESHOLD_DAYS days"
    fi
    
    if [[ $label_count -gt $MAX_LABELS_THRESHOLD ]]; then
      is_healthy=false
      unhealthy_due_to_labels=$((unhealthy_due_to_labels + 1))
      if [[ -n "$health_reasons" ]]; then
        health_reasons="$health_reasons, "
      fi
      health_reasons="${health_reasons}PR has > $MAX_LABELS_THRESHOLD labels"
    fi
    
    if [[ "$is_healthy" == "true" ]]; then
      healthy_prs=$((healthy_prs + 1))
      echo "PR #$pr_number: HEALTHY (Duration: $pr_duration_days days, Labels: $label_count)"
    else
      needs_attention_prs=$((needs_attention_prs + 1))
      echo "PR #$pr_number: NEEDS ATTENTION ($health_reasons)"
    fi
  done
  
  page=$((page + 1))
  
  if [[ $(echo "$result" | jq 'length') -lt 100 ]]; then
    break
  fi
  
  sleep 0.5  # Avoid rate limits
done

total_prs=$((healthy_prs + needs_attention_prs))
health_percentage=0
if [[ $total_prs -gt 0 ]]; then
  health_percentage=$(echo "scale=1; ($healthy_prs * 100) / $total_prs" | bc)
fi

echo "----------------------------"
echo "PR HEALTH SUMMARY"
echo "----------------------------"
echo "Total PRs analyzed: $total_prs"
echo "Healthy PRs: $healthy_prs"
echo "Needs Attention PRs: $needs_attention_prs"
echo "Needs Attention due to duration: $unhealthy_due_to_duration"
echo "Needs Attention due to labels: $unhealthy_due_to_labels"
echo "Health Percentage: ${health_percentage}%"
echo "----------------------------"
```

### 3. Contributor Activity Validation Script

Save this as `validate_contributor.sh`:

```bash
#!/bin/bash
# This script analyzes a contributor's complete activity in a repository

ORG="your-org"                  # Organization name
REPO="your-repo"                # Repository name
CONTRIBUTOR="username"          # GitHub username to analyze
START_DATE="2023-01-01T00:00:00Z"  # Analysis start date in ISO 8601 format
END_DATE="2023-12-31T23:59:59Z"    # Analysis end date in ISO 8601 format
TOKEN="$GITHUB_TOKEN"           # GitHub token from environment variable

echo "Analyzing activity for $CONTRIBUTOR in $ORG/$REPO"
echo "Period: $START_DATE to $END_DATE"
echo "----------------------------"

# 1. Get all PRs created by this contributor in the date range
echo "Fetching PRs authored by $CONTRIBUTOR..."
page=1
authored_prs=()

while true; do
  result=$(curl -s -H "Authorization: token $TOKEN" \
    -H "Accept: application/vnd.github.v3+json" \
    "https://api.github.com/repos/$ORG/$REPO/pulls?state=all&creator=$CONTRIBUTOR&sort=created&direction=desc&per_page=100&page=$page")
  
  # Extract PRs within date range
  filtered_prs=$(echo "$result" | jq -c "[.[] | select(.created_at >= \"$START_DATE\" and .created_at <= \"$END_DATE\")]")
  count=$(echo "$filtered_prs" | jq 'length')
  
  if [[ $count -eq 0 ]]; then
    if [[ $(echo "$result" | jq 'length') -eq 0 ]]; then
      break
    fi
  fi
  
  # Add to collection
  authored_prs+=($(echo "$filtered_prs" | jq -r '.[].number'))
  page=$((page + 1))
  
  if [[ $(echo "$result" | jq 'length') -lt 100 ]]; then
    break
  fi
  
  sleep 0.5  # Avoid rate limits
done

echo "Found ${#authored_prs[@]} PRs created by $CONTRIBUTOR"

# 2. Count commits in each PR (authored by this contributor)
total_pr_commits=0
for pr in "${authored_prs[@]}"; do
  commit_count=$(curl -s -H "Authorization: token $TOKEN" \
    -H "Accept: application/vnd.github.v3+json" \
    "https://api.github.com/repos/$ORG/$REPO/pulls/$pr/commits?per_page=100" | \
    jq '[.[] | select(.author.login == "'$CONTRIBUTOR'")] | length')
  
  echo "PR #$pr: $commit_count commits by $CONTRIBUTOR"
  total_pr_commits=$((total_pr_commits + commit_count))
done

# 3. Get all commits by this contributor (may include non-PR commits)
echo "Fetching all commits by $CONTRIBUTOR..."
page=1
total_repo_commits=0

while true; do
  result=$(curl -s -H "Authorization: token $TOKEN" \
    -H "Accept: application/vnd.github.v3+json" \
    "https://api.github.com/repos/$ORG/$REPO/commits?author=$CONTRIBUTOR&since=$START_DATE&until=$END_DATE&per_page=100&page=$page")
  
  count=$(echo "$result" | jq 'length')
  total_repo_commits=$((total_repo_commits + count))
  
  if [[ $count -lt 100 ]]; then
    break
  fi
  
  page=$((page + 1))
  sleep 0.5  # Avoid rate limits
done

# 4. Get PRs reviewed by this contributor
echo "Fetching PRs reviewed by $CONTRIBUTOR..."
page=1
reviewed_prs=0
approved_prs=0

# Note: GitHub API doesn't have a direct endpoint for reviews by a user
# We need to check all PRs in the date range and filter for reviews by this contributor
while true; do
  prs_result=$(curl -s -H "Authorization: token $TOKEN" \
    -H "Accept: application/vnd.github.v3+json" \
    "https://api.github.com/repos/$ORG/$REPO/pulls?state=all&sort=created&direction=desc&per_page=100&page=$page")
  
  # Extract PRs within date range
  filtered_prs=$(echo "$prs_result" | jq -c "[.[] | select(.created_at >= \"$START_DATE\" and .created_at <= \"$END_DATE\")]")
  count=$(echo "$filtered_prs" | jq 'length')
  
  if [[ $count -eq 0 ]]; then
    if [[ $(echo "$prs_result" | jq 'length') -eq 0 ]]; then
      break
    fi
  fi
  
  # Check reviews for each PR
  for pr_number in $(echo "$filtered_prs" | jq -r '.[].number'); do
    reviews=$(curl -s -H "Authorization: token $TOKEN" \
      -H "Accept: application/vnd.github.v3+json" \
      "https://api.github.com/repos/$ORG/$REPO/pulls/$pr_number/reviews")
    
    # Count reviews by this contributor
    user_reviews=$(echo "$reviews" | jq "[.[] | select(.user.login == \"$CONTRIBUTOR\")]")
    user_review_count=$(echo "$user_reviews" | jq 'length')
    
    if [[ $user_review_count -gt 0 ]]; then
      reviewed_prs=$((reviewed_prs + 1))
      
      # Check for approvals
      approval_count=$(echo "$user_reviews" | jq '[.[] | select(.state == "APPROVED")] | length')
      if [[ $approval_count -gt 0 ]]; then
        approved_prs=$((approved_prs + 1))
      fi
    fi
    
    sleep 0.2  # Avoid rate limits
  done
  
  page=$((page + 1))
  
  if [[ $(echo "$prs_result" | jq 'length') -lt 100 ]]; then
    break
  fi
  
  sleep 0.5  # Avoid rate limits
done

echo "----------------------------"
echo "CONTRIBUTOR METRICS SUMMARY for $CONTRIBUTOR"
echo "----------------------------"
echo "Authored PRs: ${#authored_prs[@]}"
echo "Commits in PRs: $total_pr_commits"
echo "Total repository commits: $total_repo_commits"
echo "PRs reviewed: $reviewed_prs"
echo "PRs approved: $approved_prs"
echo "----------------------------"
```

## Common Discrepancies

When validating metrics, be aware of these common sources of discrepancies:

### 1. Pagination Issues
**Problem**: GitHub API limits results to 100 items per page. Without proper pagination, you'll only see the first 100 PRs or commits.

**Solution**: The Python script and bash scripts included in this guide handle pagination correctly.

### 2. Time Zone Differences
**Problem**: The GitHub Metrics Reporter uses UTC for all calculations. Local date calculations might use different time zones.

**Solution**: The Python script explicitly uses UTC for all dates. For bash scripts, ensure your date calculations account for time zones.

### 3. PR Filtering Logic
**Problem**: The report filters PRs based on creation date, not merge date or update date.

**Solution**: All validation scripts use the same filter: PR created_at is between start and end dates.

### 4. Health Status Calculation
**Problem**: PR health status uses a specific algorithm based on duration and label count.

**Solution**: The validation scripts apply the exact same logic:
- Healthy: Duration â‰¤ 7 days AND label count â‰¤ 2
- Needs Attention: Duration > 7 days OR label count > 2

### 5. API Rate Limits
**Problem**: GitHub limits API requests to 5,000 per hour for authenticated requests.

**Solution**: All scripts include rate limit handling and sleep between requests.

### 6. Repository Changes
**Problem**: If PRs were deleted or commit history was rewritten after the report was generated, validation will show different results.

**Solution**: Run validation soon after report generation to minimize this risk.

## Metric-Specific Validation

### PR Counts
```bash
curl -s -H "Authorization: token $GITHUB_TOKEN" \
  "https://api.github.com/repos/{org}/{repo}/pulls?state=all&per_page=100" | \
  jq '[.[] | select(.created_at >= "2023-01-01T00:00:00Z" and .created_at <= "2023-12-31T23:59:59Z")]' | \
  jq '{total: length, merged: [.[] | select(.merged_at != null)] | length, open: [.[] | select(.state == "open")] | length}'
```

### Contributor PR Count
```bash
curl -s -H "Authorization: token $GITHUB_TOKEN" \
  "https://api.github.com/repos/{org}/{repo}/pulls?state=all&creator={username}&per_page=100" | \
  jq '[.[] | select(.created_at >= "2023-01-01T00:00:00Z" and .created_at <= "2023-12-31T23:59:59Z")]' | \
  jq 'length'
```

### Contributor Commit Count
```bash
curl -s -H "Authorization: token $GITHUB_TOKEN" \
  "https://api.github.com/repos/{org}/{repo}/commits?author={username}&since=2023-01-01T00:00:00Z&until=2023-12-31T23:59:59Z&per_page=100" | \
  jq 'length'
```

### Total File Changes
```bash
curl -s -H "Authorization: token $GITHUB_TOKEN" \
  "https://api.github.com/repos/{org}/{repo}/pulls/{pr_number}/files" | \
  jq '{files: length, additions: [.[] | .additions] | add, deletions: [.[] | .deletions] | add}'
```

By using these validation tools and understanding the common discrepancies, you can effectively verify the accuracy of your GitHub metrics reports and identify any issues that need to be addressed.
